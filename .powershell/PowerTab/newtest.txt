# variable members

$s = 'string'
$s.
$s.t
$s.ToUpper().


# fixed 

$
%
-
!


%[tab]t
![tab]ip

(ls *.dot).Count
(ls ).Count

#partial paramter type completion 

Set-ExecutionPolicy -ex [Microsoft.PowerShell.ExecutionPolicy]
Set-ExecutionPolicy -ex 'Unrestricted'

Get-EventLog application |% {$_.MachineName ,$_. # works, but caching failed

# Shares

\\localhost\
\\localhost\A
\\localhost\ADMIN$


# basic script cmdlet

help - # cmdlet 

# Enum parameters

Set-ExecutionPolicy -Ex *?
Set-ExecutionPolicy -Ex r?
Set-ExecutionPolicy -Ex ??


# enum properties 


$Host.UI.RawUI.BackgroundColor = *?
$Host.UI.RawUI.BackgroundColor = d?
$Host.UI.RawUI.BackgroundColor = ??


# automatic $_ variable

"a","b","c" |% { $_.ToUpper()}

# tokenizer test function 

function invoke-Tokenizer ($line){
  $errors = [System.Management.Automation.PSParseError[]] @()
  $tokens = [Management.Automation.PSParser]::Tokenize($line,[ref]$errors)
  $result = New-Object System.Management.Automation.PSObject
  Add-Member -InputObject $result -Name line -MemberType 'NoteProperty' -Value $line
  Add-Member -InputObject $result -Name tokens -MemberType 'NoteProperty' -Value $tokens
  Add-Member -InputObject $result -Name errors -MemberType 'NoteProperty' -Value $errors
  $result
}

function Resolve-BaseObject ($tokens) {
  $lastToken = $tokens[$tokens.count - 1] 
  $lastIndex = $tokens.IndexOf($lastToken)
  $mode = 'Start'
  $script:filter = ""
  $LastIndex..0 |% {
    $i = $_
    $token = $tokens[$i]

    switch ($mode) {
      'Start' {
        
        if ($token.type -eq 'member'){$script:filter = $token.content}
        if ($token.type -eq 'Operator'){$operator = $token.content;$mode = 'Offset'}
        #break
      }
      'offset' {
        if ($token.type -eq 'member'){$offset = $token.content + $offset}
        if ($token.type -eq 'Operator'){$lastOperator = $token.content }
        if ($token.type -eq 'GroupEnd'){$group = $token.content;$mode = 'Group'}
        if ($token.type -eq 'Variable'){
         if ($token.content -eq '_') { $group = $token.content;$mode = 'Expression' }
         else {$group = $token.content;$mode = 'Object' }
        }
        if ($token.type -eq 'Type'){$group = $token.content;$mode = 'Type' }
        #break
      }
      'group'  {
        if ($token.type -eq 'GroupStart'){$group = $token.content + $group;$mode = 'GroupEnd'}
        else {$group = $token.content + $group}
        #break
      }
      'groupEnd'  {
        if ($token.type -eq 'member'){$mode = 'Offset'}
        else {$group = $token.content + $group;$mode = 'object'}
        #break
      }
    }
  }
  $result = New-Object System.Management.Automation.PSObject
  Add-Member -InputObject $result -Name object -MemberType 'NoteProperty' -Value $group
  Add-Member -InputObject $result -Name operator -MemberType 'NoteProperty' -Value $operator
  Add-Member -InputObject $result -Name offset -MemberType 'NoteProperty' -Value $offset
  Add-Member -InputObject $result -Name lastoperator -MemberType 'NoteProperty' -Value $lastoperator
  Add-Member -InputObject $result -Name filter -MemberType 'NoteProperty' -Value $filter
  return $result
}

# diff ?

$PowerTabConfig.AutoExpandOnDot = $false
$PowerTabConfig.AutoExpandOnBackSlash = $false

# proptype 

([wmisearcher]'' ).Scope = ?
([wmisearcher]'' ).Scope = [System.Management.ManagementScope]
([wmisearcher]'' ).Scope = [System.Management.ManagementScope]:
([wmisearcher]'' ).Scope = New-Object System.Management.ManagementScope


# New member resolving ($_)

(ls).ToString().Chars(1).GetType()
$host.ToString().Chars(1).GetType()
ls |% {$_.ToString().Chars(1).GetType()} # is de goede

# Parameter parsing for 

$s = @'
function foo {
param([string]$Url, [string]$Encoding="windows-1251", [System.Management.Automation.PSCredential]$ProxyCredential = $null)
}
'@

Cmdlet Verb-Noun `
  -SupportsShouldProcess 
  {
    Param ([Mandatory] $Parameter1, Parameter2)
    Begin{}
    Process{}
    End{}
  }

Cmdlet Select-Grid -ConfirmImpact low -snapin Huddled.WPF
{
   Param (
      [Parameter(Position=0)][string[]]$Properties,
      [Parameter(Position=1)][string[]]$Title,
      [Parameter(Position=2)][string[]]$Sort,
      [Parameter(Position=3)][string[]]$Graph,
      [Parameter(Mandatory=$true, ValueFromPipeline=$true)] $InputObjects
   )
invoke-Tokenizer $s | ft

# filesystem

cd \p
hklm:\
cd hklm 
function:\
./

cd "\Program Files"
